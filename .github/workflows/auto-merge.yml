# Auto Merge PRs
# Automatically merges PRs when all requirements are met:
# - All required checks pass
# - PR is approved by required reviewers
# - No requested changes
# - Auto-merge is enabled on the PR

name: Auto Merge

on:
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge approved PRs
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            
            // Get PR number from context
            let pr_number;
            if (context.payload.pull_request) {
              pr_number = context.payload.pull_request.number;
            } else if (context.payload.check_suite) {
              // For check_suite events, get PRs associated with the commit
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha: context.payload.check_suite.head_sha
              });
              if (prs.data.length === 0) return;
              
              // Prefer an open PR targeting the default branch, then any open PR, then any PR
              const associatedPrs = prs.data;
              const openPrs = associatedPrs.filter(pr => pr.state === 'open');
              let targetPr =
                openPrs.find(pr => pr.base && pr.base.repo && pr.base.ref === pr.base.repo.default_branch) ||
                openPrs[0] ||
                associatedPrs[0];
              if (!targetPr) {
                console.log('No suitable PR found for associated commit');
                return;
              }
              pr_number = targetPr.number;
            } else {
              console.log('No PR found in context');
              return;
            }
            
            // Get PR details
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pr_number
            });
            
            console.log(`Checking PR #${pr_number}: ${pr.data.title}`);
            
            // Skip if PR is closed or merged
            if (pr.data.state !== 'open') {
              console.log('PR is not open, skipping');
              return;
            }
            
            // Skip if PR is a draft
            if (pr.data.draft) {
              console.log('PR is a draft, skipping');
              return;
            }
            
            // Skip if auto-merge is not enabled
            if (!pr.data.auto_merge) {
              console.log('Auto-merge is not enabled on this PR');
              return;
            }
            
            // Get reviews
            const reviews = await github.rest.pulls.listReviews({
              owner,
              repo,
              pull_number: pr_number
            });
            
            // Check for approval and no requested changes
            let hasApproval = false;
            let hasRequestedChanges = false;
            
            // Group reviews by reviewer (latest review wins)
            const latestReviewsByUser = {};
            for (const review of reviews.data) {
              if (!latestReviewsByUser[review.user.login] || 
                  new Date(review.submitted_at) > new Date(latestReviewsByUser[review.user.login].submitted_at)) {
                latestReviewsByUser[review.user.login] = review;
              }
            }
            
            for (const review of Object.values(latestReviewsByUser)) {
              if (review.state === 'APPROVED') {
                hasApproval = true;
              } else if (review.state === 'CHANGES_REQUESTED') {
                hasRequestedChanges = true;
              }
            }
            
            if (hasRequestedChanges) {
              console.log('PR has requested changes, not merging');
              return;
            }
            
            if (!hasApproval) {
              console.log('PR is not approved, not merging');
              return;
            }
            
            // Check if all required status checks pass
            const checkRuns = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: pr.data.head.sha
            });
            
            // Check for any in-progress or queued checks
            const inProgressChecks = checkRuns.data.check_runs.filter(
              check => check.status !== 'completed'
            );
            
            if (inProgressChecks.length > 0) {
              console.log(`${inProgressChecks.length} check(s) still in progress or queued`);
              return;
            }
            
            // Filter to completed checks only
            const completedChecks = checkRuns.data.check_runs.filter(
              check => check.status === 'completed'
            );
            
            // Ensure there is at least one check run
            if (completedChecks.length === 0) {
              console.log('No completed check runs found');
              return;
            }
            
            // Check that all completed checks passed (allowing neutral/skipped)
            const allChecksPassed = completedChecks.every(
              check => ['success', 'neutral', 'skipped'].includes(check.conclusion)
            );
            
            if (!allChecksPassed) {
              console.log('Not all checks have passed');
              const failedChecks = completedChecks.filter(
                check => !['success', 'neutral', 'skipped'].includes(check.conclusion)
              );
              console.log(`Failed checks: ${failedChecks.map(c => c.name).join(', ')}`);
              return;
            }
            
            // Also check legacy status contexts (for non-CheckRun integrations)
            const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
              owner,
              repo,
              ref: pr.data.head.sha
            });
            
            if (combinedStatus.data.state === 'pending') {
              console.log('Legacy status checks are still pending');
              return;
            }
            
            if (combinedStatus.data.state === 'failure' || combinedStatus.data.state === 'error') {
              console.log(`Legacy status checks failed: ${combinedStatus.data.state}`);
              return;
            }
            
            // All conditions met, merge the PR
            console.log('All conditions met, merging PR...');
            
            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pr_number,
                merge_method: pr.data.auto_merge.merge_method || 'squash'
              });
              
              console.log(`âœ… PR #${pr_number} merged successfully!`);
              
              // Add a comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr_number,
                body: 'ðŸŽ‰ This PR has been automatically merged as all checks passed and required approvals were received!'
              });
            } catch (error) {
              console.log(`Failed to merge PR: ${error.message}`);
            }
